<!-- HTML header for doxygen 1.13.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=11"/>
  <meta name="generator" content="Doxygen 1.12.0"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MCRO: MCRO</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="clipboard.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
  <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init()
      DoxygenAwesomeParagraphLink.init()
      DoxygenAwesomeInteractiveToc.init()
      DoxygenAwesomeTabs.init()
  </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectlogo"><img alt="Logo" src="proto-logo-0-small.png"/></td>
              <td id="projectalign">
                <div id="projectname">MCRO
                </div>
                <div id="projectbrief">C++23 utilities for Unreal Engine.</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">MCRO </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#autotoc_md5">What&#39;s a proto-plugin?</a>
  </li>
  <li class="level1">
    <a href="#autotoc_md6">What&#39;s up with _Origin suffix everywhere?</a>
  </li>
  <li class="level1">
    <a href="#autotoc_md7">What MCRO can do?</a>
    <ul>
      <li class="level2">
        <a href="#autotoc_md8">Error handling</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md9">Delegate type inferance</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md10">Advanced TEventDelegate</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md11">TTypeName</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md12">Auto modular features</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md13">Observable TState</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md14">Function Traits</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md15">Concepts</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md16">Extending the Slate declarative syntax</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md17">Text interop</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md18">ISPC parallel tasks support</a>
      </li>
      <li class="level2">
        <a href="#autotoc_md19">Last but not least</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md20">Legal</a>
  </li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="mainpage"></a></p>
<p>A C++23 utility proto-plugin for Unreal Engine, for a more civilised age.</p>
<dl class="section attention"><dt>Attention</dt><dd>This library is far from being production ready and is not recommended to be used yet at all</dd></dl>
<p><a href="https://github.com/microdee/mcro">Find the source code at</a></p>
<h1><a class="anchor" id="autotoc_md5"></a>
What's a proto-plugin?</h1>
<p>This repository is not meant to be used as its own full featured Unreal Plugin, but rather other plugins can compose this one into themselves using the <a href="https://github.com/microdee/md.Nuke.Cola?tab=readme-ov-file#folder-composition">Folder Composition</a> feature provided by <a href="https://github.com/microdee/Nuke.Unreal">Nuke.Unreal</a> (via <a href="https://github.com/microdee/md.Nuke.Cola">Nuke.Cola</a>). The recommended way to use this is via using a simple Nuke.Cola build-plugin which inherits <code>IUseMcro</code> for example:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>Nuke.Common;</div>
<div class="line"><span class="keyword">using </span>Nuke.Cola;</div>
<div class="line"><span class="keyword">using </span>Nuke.Cola.BuildPlugins;</div>
<div class="line"><span class="keyword">using </span>Nuke.Unreal;</div>
<div class="line"> </div>
<div class="line">[ImplicitBuildInterface]</div>
<div class="line"><span class="keyword">public</span> <span class="keyword">interface </span>IUseMcroInMyProject : IUseMcro</div>
<div class="line">{</div>
<div class="line">    Target UseMcro =&gt; _ =&gt; _</div>
<div class="line">        .McroGraph()</div>
<div class="line">        .DependentFor&lt;UnrealBuild&gt;(b =&gt; b.Prepare)</div>
<div class="line">        .Executes(() =&gt;</div>
<div class="line">        {</div>
<div class="line">            UseMcroAt(this.ScriptFolder(), <span class="stringliteral">&quot;MyProjectSuffix&quot;</span>);</div>
<div class="line">        });</div>
<div class="line">}</div>
</div><!-- fragment --><p>If this seems painful please blame Epic Games who decided to not allow <strike>marketplace</strike>/Fab plugins to depend on each other, or at least depend on free and open source plugins from other sources. So I had to come up with all this "Folder Composition" nonsense so end-users might be able to use multiple of my plugins sharing common dependencies without module name conflicts.</p>
<p>To use MCRO as its own plugin without the need for Nuke.Unreal, see this repository: <b>(DOESN'T EXIST YET)</b></p>
<h1><a class="anchor" id="autotoc_md6"></a>
What's up with _Origin suffix everywhere?</h1>
<p>When this proto plugin is imported into other plugins, this suffix is used for disambiguation, in case the end-user uses multiple pre-compiled plugins depending on MCRO. If this seems annoying please refer to the paragraph earlier.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
What MCRO can do?</h1>
<p>Here are some code appetizers without going too deep into their details. The demonstrated features usually can do a lot more than what's shown here.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Error handling</h2>
<p>An elegant workflow for dealing with code which has can and probably will fail. It allows the developer to record the circumstances of an error, record its propagation accross components which are affected, add suggestions to the user or fellow developers for fixing the error, and display that with a modal Slate window, or print it into logs following a YAML structure.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="d3/d35/CppException_8h.html">Mcro/Error/CppException.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">FCanFail FK4ADevice::Tick_Sync()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="dd/d58/namespaceMcro_1_1Error.html">Mcro::Error</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="de/dba/Error_8h.html#af37be15dc2b5053c9c6f901363b2a756">ASSERT_RETURN</a>(Device.is_valid(),</div>
<div class="line">        -&gt;AsCrashing()</div>
<div class="line">        -&gt;BreakDebugger()</div>
<div class="line">        -&gt;WithCppStackTrace()</div>
<div class="line">        -&gt;Notify(LastError)</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">        k4a::capture capture;</div>
<div class="line">        <a class="code hl_define" href="de/dba/Error_8h.html#af37be15dc2b5053c9c6f901363b2a756">ASSERT_RETURN</a>(Device.get_capture(&amp;capture), -&gt;Notify(LastError))</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">auto</span> color = capture.get_color_image(); ColorStream-&gt;Active)</div>
<div class="line">        {</div>
<div class="line">            <a class="code hl_define" href="db/df5/AssertMacros_8h.html#afa32959b04a99d2f4a56cd141e34a9bd">PROPAGATE_FAIL</a>(ColorStream-&gt;Push(color), -&gt;Notify(LastError))</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">auto</span> depth = capture.get_depth_image(); DepthStream-&gt;Active)</div>
<div class="line">        {</div>
<div class="line">            <a class="code hl_define" href="db/df5/AssertMacros_8h.html#afa32959b04a99d2f4a56cd141e34a9bd">PROPAGATE_FAIL</a>(DepthStream-&gt;Push(depth), -&gt;Notify(LastError))</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">auto</span> ir = capture.get_ir_image(); IRStream-&gt;Active)</div>
<div class="line">        {</div>
<div class="line">            <a class="code hl_define" href="db/df5/AssertMacros_8h.html#afa32959b04a99d2f4a56cd141e34a9bd">PROPAGATE_FAIL</a>(IRStream-&gt;Push(ir), -&gt;Notify(LastError))</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (k4a::error <span class="keyword">const</span>&amp; exception)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> MakeError(IError::Make(<span class="keyword">new</span> <a class="code hl_class" href="db/d63/classMcro_1_1Error_1_1TCppException.html">TCppException</a>(exception))</div>
<div class="line">            -&gt;AsFatal()-&gt;WithCppStackTrace()-&gt;WithLocation()</div>
<div class="line">            -&gt;Notify(LastError)</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="dd/d58/namespaceMcro_1_1Error.html#a27d33ed2b445ca7310f71a30e9ad956f">Success</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aAssertMacros_8h_html_afa32959b04a99d2f4a56cd141e34a9bd"><div class="ttname"><a href="db/df5/AssertMacros_8h.html#afa32959b04a99d2f4a56cd141e34a9bd">PROPAGATE_FAIL</a></div><div class="ttdeci">#define PROPAGATE_FAIL(expression)</div></div>
<div class="ttc" id="aCppException_8h_html"><div class="ttname"><a href="d3/d35/CppException_8h.html">CppException.h</a></div></div>
<div class="ttc" id="aError_8h_html_af37be15dc2b5053c9c6f901363b2a756"><div class="ttname"><a href="de/dba/Error_8h.html#af37be15dc2b5053c9c6f901363b2a756">ASSERT_RETURN</a></div><div class="ttdeci">#define ASSERT_RETURN(condition)</div><div class="ttdef"><b>Definition</b> <a href="de/dba/Error_8h_source.html#l00606">Error.h:606</a></div></div>
<div class="ttc" id="aclassMcro_1_1Error_1_1TCppException_html"><div class="ttname"><a href="db/d63/classMcro_1_1Error_1_1TCppException.html">Mcro::Error::TCppException</a></div><div class="ttdef"><b>Definition</b> <a href="d3/d35/CppException_8h_source.html#l00048">CppException.h:49</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1Error_html"><div class="ttname"><a href="dd/d58/namespaceMcro_1_1Error.html">Mcro::Error</a></div><div class="ttdef"><b>Definition</b> <a href="d7/d3f/Error_8Fwd_8h_source.html#l00018">Error.Fwd.h:19</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1Error_html_a27d33ed2b445ca7310f71a30e9ad956f"><div class="ttname"><a href="dd/d58/namespaceMcro_1_1Error.html#a27d33ed2b445ca7310f71a30e9ad956f">Mcro::Error::Success</a></div><div class="ttdeci">FORCEINLINE FCanFail Success()</div><div class="ttdef"><b>Definition</b> <a href="de/dba/Error_8h_source.html#l00590">Error.h:590</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
Delegate type inferance</h2>
<p>In <code><a class="el" href="d0/dec/namespaceMcro_1_1Delegates.html">Mcro::Delegates</a></code> namespace there's a bunch of overloads of <code>From</code> function which can infer a delegate type and its intended binding only based on its input arguments. It means a couple of things:</p>
<ol type="1">
<li>The potentially lengthy delegate types are no longer needed to be repeated.</li>
<li>Creating an alias for each (multicast) delegate is no longer a must have.</li>
</ol>
<p>For example given an imaginary type with a terrible API for some reason</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">struct </span>FObservable</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>FOnStateResetTheFirstTimeEvent = TMulticastDelegate&lt;void(FObservable <span class="keyword">const</span>&amp;)&gt;;</div>
<div class="line">    FOnStateResetTheFirstTimeEvent OnStateResetTheFirstTimeEvent;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>FDefaultInitializerDelegate = TDelegate&lt;FString(FObservable <span class="keyword">const</span>&amp;)&gt;;</div>
<div class="line">    <span class="keywordtype">void</span> SetDefaultInitializer(FDefaultInitializerDelegate <span class="keyword">const</span>&amp; defaultInit)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// etc ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// etc...</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="tabbed"></div><div class="tabbed"><ul>
<li>
<p class="startli"></p>
<p class="interli"><b class="tab-title">We can do:</b></p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="d4/dbf/DelegateFrom_8h.html">Mcro/Delegates/DelegateFrom.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>FListener : TSharedFromThis&lt;FListener&gt;</div>
<div class="line">{</div>
<div class="line">    TMulticastDelegate&lt;void(FObservable <span class="keyword">const</span>&amp;)&gt; PropagateEvent;</div>
<div class="line">    <span class="keywordtype">void</span> OnFirstStateReset(FObservable <span class="keyword">const</span>&amp; observable, FString <span class="keyword">const</span>&amp; capturedData)</div>
<div class="line">    <span class="keywordtype">void</span> BindTo(FObservable&amp; observable)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">using </span><a class="code hl_namespace" href="d0/dec/namespaceMcro_1_1Delegates.html">Mcro::Delegates</a>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Repeating the delegate type on call site is not necessary</span></div>
<div class="line">        observable.SetDefaultInitializer(From(<span class="keyword">this</span>, [<span class="keyword">this</span>](FObservable <span class="keyword">const</span>&amp;) -&gt; FString</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> TEXT(<span class="stringliteral">&quot;Some default value&quot;</span>);</div>
<div class="line">        }));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Chaining events like this is a single line</span></div>
<div class="line">        observable.OnStateResetTheFirstTimeEvent.Add(From(<span class="keyword">this</span>, PropagateEvent));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// No need to decide on the method of binding, the most suitable one is chosen via templating</span></div>
<div class="line">        observable.OnStateResetTheFirstTimeEvent.Add(From(<span class="keyword">this</span>, &amp;FListener::OnFirstStateReset, TEXT(<span class="stringliteral">&quot;Capture this&quot;</span>)));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aDelegateFrom_8h_html"><div class="ttname"><a href="d4/dbf/DelegateFrom_8h.html">DelegateFrom.h</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1Delegates_html"><div class="ttname"><a href="d0/dec/namespaceMcro_1_1Delegates.html">Mcro::Delegates</a></div><div class="ttdef"><b>Definition</b> <a href="d6/d11/AsNative_8h_source.html#l00018">AsNative.h:19</a></div></div>
</div><!-- fragment --><p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p class="interli"><b class="tab-title">Equivalent vanilla Unreal delegates:</b></p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">struct </span>FListener : TSharedFromThis&lt;FListener&gt;</div>
<div class="line">{</div>
<div class="line">    TMulticastDelegate&lt;void(FObservable <span class="keyword">const</span>&amp;)&gt; PropagateEvent;</div>
<div class="line">    <span class="keywordtype">void</span> OnFirstStateReset(FObservable <span class="keyword">const</span>&amp; observable, FString <span class="keyword">const</span>&amp; capturedData)</div>
<div class="line">    <span class="keywordtype">void</span> BindTo(FObservable&amp; observable)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Delegate API in these situations is pretty verbose</span></div>
<div class="line">        observable.SetDefaultInitializer(FDefaultInitializerDelegate::CreateSPLambda(<span class="keyword">this</span>, [<span class="keyword">this</span>](FObservable <span class="keyword">const</span>&amp;) -&gt; FString</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> TEXT(<span class="stringliteral">&quot;Some default value&quot;</span>);</div>
<div class="line">        }));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Chaining events is a new Feature introduced with From</span></div>
<div class="line">        observable.OnStateResetTheFirstTimeEvent.AddSPLambda(<span class="keyword">this</span>, [<span class="keyword">this</span>](FObservable <span class="keyword">const</span>&amp; observableArg)</div>
<div class="line">        {</div>
<div class="line">            PropagateEvent.Broadcast(observableArg);</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Ok here the difference is almost nothing</span></div>
<div class="line">        observable.OnStateResetTheFirstTimeEvent.AddSP(<span class="keyword">this</span>, &amp;FListener::OnFirstStateReset, TEXT(<span class="stringliteral">&quot;Capture this&quot;</span>));</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p class="interli"></p>
<p class="endli"></p>
</li>
</ul>
</div><div class="tabbed"></div><p>There's also a dynamic / native (multicast) delegate interop including similar chaining demonstrated here.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Advanced TEventDelegate</h2>
<p>Did your thing ever load after an event which your thing depends on, but now you have to somehow detect that the event has already happened and you have to execute your thing manually? With <code><a class="el" href="d4/d51/classMcro_1_1Delegates_1_1TEventDelegate.html">Mcro::Delegates::TEventDelegate</a></code> this situation has a lot less friction:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="df/d51/EventDelegate_8h.html">Mcro/Delegates/EventDelegate.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// TBelatedEventDelegate is an alias for TEventDelegate&lt;Signature, BelatedInvoke&gt;</span></div>
<div class="line"><a class="code hl_class" href="d4/d51/classMcro_1_1Delegates_1_1TEventDelegate.html">TBelatedEventDelegate</a>&lt;void(<span class="keywordtype">int</span>)&gt; SomeEvent;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Broadcast first</span></div>
<div class="line">SomeEvent.Broadcast(42);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Late subscribers will not be left behind</span></div>
<div class="line">SomeEvent.Add(From([](<span class="keywordtype">int</span> value)</div>
<div class="line">{</div>
<div class="line">    UE_LOG(LogTemp, Display, TEXT(<span class="stringliteral">&quot;The last argument this event broadcasted with: %d&quot;</span>), value);</div>
<div class="line">}));</div>
<div class="line"><span class="comment">// -&gt; The last argument this event broadcasted with: 42</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This event doesn&#39;t have this behavior set by default</span></div>
<div class="line"><a class="code hl_class" href="d4/d51/classMcro_1_1Delegates_1_1TEventDelegate.html">TEventDelegate</a>&lt;void(<span class="keywordtype">int</span>)&gt; SomeOtherEvent;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Broadcast first</span></div>
<div class="line">SomeOtherEvent.Broadcast(1337);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Late subscribers still can explicitly ask to be notified</span></div>
<div class="line">SomeOtherEvent.Add(</div>
<div class="line">    From([](<span class="keywordtype">int</span> value)</div>
<div class="line">    {</div>
<div class="line">        UE_LOG(LogTemp, Display, TEXT(<span class="stringliteral">&quot;The last argument this event broadcasted with: %d&quot;</span>), value);</div>
<div class="line">    }),</div>
<div class="line">    <a class="code hl_enumvalue" href="d0/dec/namespaceMcro_1_1Delegates.html#aab1ceef50a2938ef8abc61f78ff30e77ab809cf5d82dfc014a733a335a29caeb3">BelatedInvoke</a></div>
<div class="line">);</div>
<div class="line"><span class="comment">// -&gt; The last argument this event broadcasted with: 1337</span></div>
<div class="ttc" id="aEventDelegate_8h_html"><div class="ttname"><a href="df/d51/EventDelegate_8h.html">EventDelegate.h</a></div></div>
<div class="ttc" id="aclassMcro_1_1Delegates_1_1TEventDelegate_html"><div class="ttname"><a href="d4/d51/classMcro_1_1Delegates_1_1TEventDelegate.html">Mcro::Delegates::TEventDelegate</a></div><div class="ttdef"><b>Definition</b> <a href="df/d51/EventDelegate_8h_source.html#l00048">EventDelegate.h:48</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1Delegates_html_aab1ceef50a2938ef8abc61f78ff30e77ab809cf5d82dfc014a733a335a29caeb3"><div class="ttname"><a href="d0/dec/namespaceMcro_1_1Delegates.html#aab1ceef50a2938ef8abc61f78ff30e77ab809cf5d82dfc014a733a335a29caeb3">Mcro::Delegates::BelatedInvoke</a></div><div class="ttdeci">@ BelatedInvoke</div><div class="ttdef"><b>Definition</b> <a href="df/d51/EventDelegate_8h_source.html#l00035">EventDelegate.h:35</a></div></div>
</div><!-- fragment --><p>Or your thing only needs to do its tasks on the first time a frequently invoked event is triggered?</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="df/d51/EventDelegate_8h.html">Mcro/Delegates/EventDelegate.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="d4/d51/classMcro_1_1Delegates_1_1TEventDelegate.html">TEventDelegate</a>&lt;void(<span class="keywordtype">int</span>)&gt; SomeFrequentEvent;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This function should only be called the first time after its binding</span></div>
<div class="line">SomeFrequentEvent.Add(</div>
<div class="line">    From([](<span class="keywordtype">int</span> value)</div>
<div class="line">    {</div>
<div class="line">        UE_LOG(LogTemp, Display, TEXT(<span class="stringliteral">&quot;This value is printed only once: %d&quot;</span>), value);</div>
<div class="line">    }),</div>
<div class="line">    InvokeOnce</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">SomeFrequentEvent.Broadcast(1);</div>
<div class="line"><span class="comment">// -&gt; This value is printed only once: 1</span></div>
<div class="line">SomeFrequentEvent.Broadcast(2);</div>
<div class="line"><span class="comment">// (nothing is executed here)</span></div>
</div><!-- fragment --><p>Chaining events?</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="df/d51/EventDelegate_8h.html">Mcro/Delegates/EventDelegate.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">TMulticastDelegate&lt;void(<span class="keywordtype">int</span>)&gt; LowerLevelEvent;</div>
<div class="line"><a class="code hl_class" href="d4/d51/classMcro_1_1Delegates_1_1TEventDelegate.html">TEventDelegate</a>&lt;void(<span class="keywordtype">int</span>)&gt; HigherLevelEvent;</div>
<div class="line"> </div>
<div class="line">HigherLevelEvent.Add(From([](<span class="keywordtype">int</span> value)</div>
<div class="line">{</div>
<div class="line">    UE_LOG(LogTemp, Display, TEXT(<span class="stringliteral">&quot;Value: %d&quot;</span>), value);</div>
<div class="line">}));</div>
<div class="line">LowerLevelEvent.Add(HigherLevelEvent.Delegation(<span class="keyword">this</span> <span class="comment">/* optionally bind an object */</span>));</div>
<div class="line"> </div>
<div class="line">LoverLevelEvent.Broadcast(42);</div>
<div class="line"><span class="comment">// -&gt; Value: 42</span></div>
</div><!-- fragment --><p>Of course the above chaining can be combined with belated~ or one-time invocations.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
TTypeName</h2>
<p>C++ 20 can do string manipulation in compile time, <a href="https://github.com/hanickadot/compile-time-regular-expressions">including regex</a>. With that, compiler specific "pretty function" macros become a key tool for simple static reflection. Based on that MCRO has <code>TTypeName</code></p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="d0/de3/TypeName_8h.html">Mcro/TypeName.h</a>&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="df/d09/namespaceMcro_1_1TypeName.html">Mcro::TypeName</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>FMyType</div>
<div class="line">{</div>
<div class="line">    FStringView GetTypeString() { <span class="keywordflow">return</span> TTypeName&lt;FMyType&gt;; } <span class="comment">// -&gt; &quot;FMyType&quot; as view</span></div>
<div class="line">}</div>
<div class="ttc" id="aTypeName_8h_html"><div class="ttname"><a href="d0/de3/TypeName_8h.html">TypeName.h</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1TypeName_html"><div class="ttname"><a href="df/d09/namespaceMcro_1_1TypeName.html">Mcro::TypeName</a></div><div class="ttdef"><b>Definition</b> <a href="d0/de3/TypeName_8h_source.html#l00084">TypeName.h:85</a></div></div>
</div><!-- fragment --><p>even better with C++ 23 deducing this</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="d0/de3/TypeName_8h.html">Mcro/TypeName.h</a>&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="df/d09/namespaceMcro_1_1TypeName.html">Mcro::TypeName</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>FMyBaseType</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// returns const-ref to a templated global variable</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Self&gt;</div>
<div class="line">    FString <span class="keyword">const</span>&amp; GetTypeString(<span class="keyword">this</span> Self&amp;&amp;)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> TTypeString&lt;Self&gt;; }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>FMyDerivedType : FMyBaseType {}</div>
<div class="line"> </div>
<div class="line">FMyDerivedType myVar;</div>
<div class="line">UE_LOG(LogTemp, Display, TEXT(<span class="stringliteral">&quot;This is `%s`&quot;</span>), *myVar.GetTypeString());</div>
<div class="line"><span class="comment">// -&gt; This is `FMyDerivedType`</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// BUT!</span></div>
<div class="line"> </div>
<div class="line">FMyBaseType <span class="keyword">const</span>&amp; myBaseVar = myVar;</div>
<div class="line">UE_LOG(LogTemp, Display, TEXT(<span class="stringliteral">&quot;This is `%s`&quot;</span>), *myBaseVar.GetTypeString());</div>
<div class="line"><span class="comment">// -&gt; This is `FMyBaseType`</span></div>
</div><!-- fragment --><p>MCRO provides a base type <code>IHaveType</code> for storing the final type as an <code>FName</code> to avoid situations like above</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="d7/df8/Types_8h.html">Mcro/Types.h</a>&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="da/d89/namespaceMcro_1_1Types.html">Mcro::Types</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>FMyBaseType : <a class="code hl_class" href="d8/d19/classMcro_1_1Types_1_1IHaveType.html">IHaveType</a> {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>FMyDerivedType : FMyBaseType</div>
<div class="line">{</div>
<div class="line">    FMyDerivedType() { SetType(); }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">FMyDerivedType myVar;</div>
<div class="line">UE_LOG(LogTemp, Display, TEXT(<span class="stringliteral">&quot;This is as expected a `%s`&quot;</span>), *myVar.GetType().ToString());</div>
<div class="line"><span class="comment">// -&gt; This is as expected `FMyDerivedType`</span></div>
<div class="line"> </div>
<div class="line">FMyBaseType <span class="keyword">const</span>&amp; myBaseVar = myVar;</div>
<div class="line">UE_LOG(</div>
<div class="line">    LogTemp, Display,</div>
<div class="line">    TEXT(<span class="stringliteral">&quot;But asking the base type will still preserve `%s`&quot;</span>),</div>
<div class="line">    *myBaseVar.GetType().ToString()</div>
<div class="line">);</div>
<div class="line"><span class="comment">// -&gt; But asking the base type will still preserve `FMyDerivedType`</span></div>
<div class="ttc" id="aTypes_8h_html"><div class="ttname"><a href="d7/df8/Types_8h.html">Types.h</a></div></div>
<div class="ttc" id="aclassMcro_1_1Types_1_1IHaveType_html"><div class="ttname"><a href="d8/d19/classMcro_1_1Types_1_1IHaveType.html">Mcro::Types::IHaveType</a></div><div class="ttdef"><b>Definition</b> <a href="d7/df8/Types_8h_source.html#l00041">Types.h:42</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1Types_html"><div class="ttname"><a href="da/d89/namespaceMcro_1_1Types.html">Mcro::Types</a></div><div class="ttdef"><b>Definition</b> <a href="d7/df8/Types_8h_source.html#l00021">Types.h:22</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
Auto modular features</h2>
<p>One use of <code>TTypeName</code> is making modular features easier to use:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;Mcro/AutoModularFeatures.h&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span>Mcro::AutoModularFeatures;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In central API module</span></div>
<div class="line"><span class="keyword">class </span>IProblemSolvingFeature : <span class="keyword">public</span> TAutoModularFeature&lt;IProblemSolvingFeature&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> SolveAllProblems() = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In another implementation specific module</span></div>
<div class="line"><span class="comment">// Define implementation first</span></div>
<div class="line"><span class="keyword">class </span>FProblemSolver : <span class="keyword">public</span> IProblemSolvingFeature, <span class="keyword">public</span> IFeatureImplementation</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FProblemSolver() { Register(); }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> SolveAllProblems() <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create one global instance</span></div>
<div class="line">FProblemSolver GProblemSolver;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In some other place, which doesn&#39;t know about the above implementation, the feature is used:</span></div>
<div class="line">IProblemSolvingFeature::Get().SolveAllProblems();</div>
</div><!-- fragment --><p>Notice how the feature name has never needed to be explicitly specified as a string, because the type name is used under the hood.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Observable TState</h2>
<p>You have data members of your class, but you also want to notify others about how that's changing?</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="d5/de3/Observable_8h.html">Mcro/Observable.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="d4/dbf/DelegateFrom_8h.html">Mcro/Delegates/DelegateFrom.h</a>&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="d6/da2/namespaceMcro_1_1Observable.html">Mcro::Observable</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>FMyStuff</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="d7/d5e/structMcro_1_1Observable_1_1TState.html">TState&lt;int, StorePrevious&gt;</a> State {-1};</div>
<div class="line"> </div>
<div class="line">    FMyStuff()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Get previous values as well when `StorePrevious` flag is active</span></div>
<div class="line">        State.<a class="code hl_function" href="d7/d5e/structMcro_1_1Observable_1_1TState.html#af20d748b285a12ca2cab03a77e69b75a">OnChange</a>([](<span class="keywordtype">int</span> next, TOptional&lt;int&gt; previous)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// If `StorePrevious` flag is active we should always have a value in `previous`</span></div>
<div class="line">            <span class="comment">// so we should never see -2</span></div>
<div class="line">            UE_LOG(LogTemp, Display, TEXT(<span class="stringliteral">&quot;Changed from %d to %d&quot;</span>), previous.Get(-2), next);</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Listen to change only the first time</span></div>
<div class="line">        State.OnChange(</div>
<div class="line">            [](<span class="keywordtype">int</span> next) { UE_LOG(LogTemp, Display, TEXT(<span class="stringliteral">&quot;The first changed value is %d&quot;</span>), next); },</div>
<div class="line">            <a class="code hl_enumvalue" href="d0/dec/namespaceMcro_1_1Delegates.html#aab1ceef50a2938ef8abc61f78ff30e77ae7709cc6e00d5e1ac96bc00a38f4bd1b">InvokeOnce</a></div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Update(<span class="keywordtype">int</span> input)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (State.HasChangedFrom(input))</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Do things only when input value has changed from previous update</span></div>
<div class="line">            <span class="comment">// Combine it with short-circuiting maybe ;)</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>FFoobar : TSharedFromThis&lt;FFoobar&gt;</div>
<div class="line">{</div>
<div class="line">    FMyStuff MyStuff;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Thing(<a class="code hl_struct" href="dd/dcf/structMcro_1_1Observable_1_1TChangeData.html">TChangeData&lt;T&gt;</a> <span class="keyword">const</span>&amp; change, FString <span class="keyword">const</span>&amp; capture)</div>
<div class="line">    {</div>
<div class="line">        UE_LOG(LogTemp, Display, TEXT(<span class="stringliteral">&quot;React to %d with %s&quot;</span>), change.<a class="code hl_variable" href="dd/dcf/structMcro_1_1Observable_1_1TChangeData.html#a25a0f6961761740bca074faad4a38ca8">Next</a>, *capture);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Do()</div>
<div class="line">    {</div>
<div class="line">        MyStuff.Update(1);</div>
<div class="line">        <span class="comment">// -&gt; Changed from -1 to 1</span></div>
<div class="line">        <span class="comment">// -&gt; The first changed value is 1</span></div>
<div class="line">        MyStuff.Update(2);</div>
<div class="line">        <span class="comment">// -&gt; Changed from 1 to 2</span></div>
<div class="line">        MyStuff.Update(2);</div>
<div class="line">        <span class="comment">// (nothing is logged as previous update was also 2)</span></div>
<div class="line">        MyStuff.OnChange(</div>
<div class="line">            [](<span class="keywordtype">int</span> next) { UE_LOG(LogTemp, Display, TEXT(<span class="stringliteral">&quot;Arriving late %d&quot;</span>), next); },</div>
<div class="line">            <a class="code hl_enumvalue" href="d0/dec/namespaceMcro_1_1Delegates.html#aab1ceef50a2938ef8abc61f78ff30e77ab809cf5d82dfc014a733a335a29caeb3">BelatedInvoke</a></div>
<div class="line">        );</div>
<div class="line">        <span class="comment">// -&gt; Arriving late 2</span></div>
<div class="line">        MyStuff.Update(3);</div>
<div class="line">        <span class="comment">// -&gt; Changed from 2 to 3</span></div>
<div class="line">        <span class="comment">// -&gt; Arriving late 3</span></div>
<div class="line">        MyStuff.OnChange(<a class="code hl_function" href="d0/dec/namespaceMcro_1_1Delegates.html#aa9afc24b49261d326ba6dd0d1e2afa73">From</a>(<span class="keyword">this</span>, &amp;FFoobar::Thing, TEXT(<span class="stringliteral">&quot;a unicorn&quot;</span>)));</div>
<div class="line">        MyStuff.Update(4)</div>
<div class="line">        <span class="comment">// -&gt; Changed from 3 to 4</span></div>
<div class="line">        <span class="comment">// -&gt; Arriving late 4</span></div>
<div class="line">        <span class="comment">// -&gt; React to 4 with a unicorn</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aObservable_8h_html"><div class="ttname"><a href="d5/de3/Observable_8h.html">Observable.h</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1Delegates_html_aa9afc24b49261d326ba6dd0d1e2afa73"><div class="ttname"><a href="d0/dec/namespaceMcro_1_1Delegates.html#aa9afc24b49261d326ba6dd0d1e2afa73">Mcro::Delegates::From</a></div><div class="ttdeci">TInferredDelegate&lt; Function, Captures... &gt; From(Function func, const Captures &amp;... captures)</div><div class="ttdef"><b>Definition</b> <a href="d4/dbf/DelegateFrom_8h_source.html#l00057">DelegateFrom.h:57</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1Delegates_html_aab1ceef50a2938ef8abc61f78ff30e77ae7709cc6e00d5e1ac96bc00a38f4bd1b"><div class="ttname"><a href="d0/dec/namespaceMcro_1_1Delegates.html#aab1ceef50a2938ef8abc61f78ff30e77ae7709cc6e00d5e1ac96bc00a38f4bd1b">Mcro::Delegates::InvokeOnce</a></div><div class="ttdeci">@ InvokeOnce</div><div class="ttdef"><b>Definition</b> <a href="df/d51/EventDelegate_8h_source.html#l00032">EventDelegate.h:32</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1Observable_html"><div class="ttname"><a href="d6/da2/namespaceMcro_1_1Observable.html">Mcro::Observable</a></div><div class="ttdef"><b>Definition</b> <a href="dc/da3/Observable_8Fwd_8h_source.html#l00023">Observable.Fwd.h:24</a></div></div>
<div class="ttc" id="astructMcro_1_1Observable_1_1TChangeData_html"><div class="ttname"><a href="dd/dcf/structMcro_1_1Observable_1_1TChangeData.html">Mcro::Observable::TChangeData</a></div><div class="ttdef"><b>Definition</b> <a href="d5/de3/Observable_8h_source.html#l00029">Observable.h:30</a></div></div>
<div class="ttc" id="astructMcro_1_1Observable_1_1TChangeData_html_a25a0f6961761740bca074faad4a38ca8"><div class="ttname"><a href="dd/dcf/structMcro_1_1Observable_1_1TChangeData.html#a25a0f6961761740bca074faad4a38ca8">Mcro::Observable::TChangeData::Next</a></div><div class="ttdeci">T Next</div><div class="ttdef"><b>Definition</b> <a href="d5/de3/Observable_8h_source.html#l00051">Observable.h:51</a></div></div>
<div class="ttc" id="astructMcro_1_1Observable_1_1TState_html"><div class="ttname"><a href="d7/d5e/structMcro_1_1Observable_1_1TState.html">Mcro::Observable::TState</a></div><div class="ttdef"><b>Definition</b> <a href="d5/de3/Observable_8h_source.html#l00226">Observable.h:227</a></div></div>
<div class="ttc" id="astructMcro_1_1Observable_1_1TState_html_af20d748b285a12ca2cab03a77e69b75a"><div class="ttname"><a href="d7/d5e/structMcro_1_1Observable_1_1TState.html#af20d748b285a12ca2cab03a77e69b75a">Mcro::Observable::TState::OnChange</a></div><div class="ttdeci">virtual FDelegateHandle OnChange(TDelegate&lt; void(TChangeData&lt; T &gt; const &amp;)&gt; onChange, EInvokeMode invokeMode=DefaultInvocation) override</div><div class="ttdef"><b>Definition</b> <a href="d5/de3/Observable_8h_source.html#l00330">Observable.h:330</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
Function Traits</h2>
<p>Make templates dealing with function types more readable and yet more versatile via the <code><a class="el" href="d5/de0/namespaceMcro_1_1FunctionTraits.html">Mcro::FunctionTraits</a></code> namespace. This is the foundation of many intricate teemplates <a class="el" href="d8/d63/namespaceMcro.html">Mcro</a> can offer.</p>
<p>Constraint/infer template parameters from the signature of an input function. (This is an annotated exempt from <code><a class="el" href="de/d2e/namespaceMcro_1_1UObjects_1_1Init.html">Mcro::UObjects::Init</a></code>)</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="d7/d25/FunctionTraits_8h.html">Mcro/FunctionTraits.h</a>&quot;</span> <span class="comment">// it also beings in Concepts</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="de/d2e/namespaceMcro_1_1UObjects_1_1Init.html">Mcro::UObjects::Init</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="d5/de0/namespaceMcro_1_1FunctionTraits.html">Mcro::FunctionTraits</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;</div>
<div class="line">        <span class="comment">// CFunctorObject constraints to a lambda function</span></div>
<div class="line">        <span class="comment">// use CFunctionLike to allow anything callable including function pointers</span></div>
<div class="line">        CFunctorObject Initializer,</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Get the first argument of `Initializer`</span></div>
<div class="line">        <span class="keyword">typename</span> Argument = <a class="code hl_typedef" href="d5/de0/namespaceMcro_1_1FunctionTraits.html#a03c6b0c1fd4799038c4fc4add5242f1d">TFunction_Arg&lt;Initializer, 0&gt;</a>,</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// That argument must be a UObject, and also cache its type</span></div>
<div class="line">        CUObject Result = std::decay_t&lt;Argument&gt;</div>
<div class="line">    &gt;</div>
<div class="line">    <span class="comment">// That argument  must also be an l-value ref</span></div>
<div class="line">    <span class="keyword">requires</span> std::is_lvalue_reference_v&lt;Argument&gt;</div>
<div class="line">    Result* Construct(FConstructObjectParameters&amp;&amp; params, Initializer&amp;&amp; init)</div>
<div class="line">    { ... }</div>
<div class="line">}</div>
<div class="ttc" id="aFunctionTraits_8h_html"><div class="ttname"><a href="d7/d25/FunctionTraits_8h.html">FunctionTraits.h</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1FunctionTraits_html"><div class="ttname"><a href="d5/de0/namespaceMcro_1_1FunctionTraits.html">Mcro::FunctionTraits</a></div><div class="ttdef"><b>Definition</b> <a href="d7/d25/FunctionTraits_8h_source.html#l00019">FunctionTraits.h:20</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1FunctionTraits_html_a03c6b0c1fd4799038c4fc4add5242f1d"><div class="ttname"><a href="d5/de0/namespaceMcro_1_1FunctionTraits.html#a03c6b0c1fd4799038c4fc4add5242f1d">Mcro::FunctionTraits::TFunction_Arg</a></div><div class="ttdeci">typename TFunctionTraits&lt; std::decay_t&lt; T &gt; &gt;::template Arg&lt; I &gt; TFunction_Arg</div><div class="ttdef"><b>Definition</b> <a href="d7/d25/FunctionTraits_8h_source.html#l00134">FunctionTraits.h:134</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1UObjects_1_1Init_html"><div class="ttname"><a href="de/d2e/namespaceMcro_1_1UObjects_1_1Init.html">Mcro::UObjects::Init</a></div><div class="ttdef"><b>Definition</b> <a href="db/db1/Init_8h_source.html#l00017">Init.h:18</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Concepts</h2>
<p>There's a copy of the C++ 20 STL Concepts library in <code><a class="el" href="d2/d09/namespaceMcro_1_1Concepts.html">Mcro::Concepts</a></code> namespace but with more Unreal friendly nameing. Also it adds some conveniance concepts, like <code>*Decayed</code> versions of type constraints, or some Unreal specific constraints like <code>CSharedRefOrPtr</code> or <code>CUObject</code></p>
<h2><a class="anchor" id="autotoc_md16"></a>
Extending the Slate declarative syntax</h2>
<p><code><a class="el" href="df/df4/namespaceMcro_1_1Slate.html">Mcro::Slate</a></code> adds the <code>/</code> operator to be used in Slate UI declarations, which can work with functions describing a common block of attributes for given widget.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;Mcro/Slate&quot;</span>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="df/df4/namespaceMcro_1_1Slate.html">Mcro::Slate</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a reusable block of attributes</span></div>
<div class="line"><span class="keyword">auto</span> Text(FString <span class="keyword">const</span>&amp; text) -&gt; <a class="code hl_typedef" href="df/df4/namespaceMcro_1_1Slate.html#a0a93c9ab0e9db18e32d30eab8bde6323">TAttributeBlock&lt;STextBlock&gt;</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> [&amp;](STextBlock::FArguments&amp; args) -&gt; <span class="keyword">auto</span>&amp;</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> args</div>
<div class="line">        . Text(FText::FromString(text))</div>
<div class="line">        . Font(FCoreStyle::GetDefaultFontStyle(<span class="stringliteral">&quot;Mono&quot;</span>, 12));</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nest these blocks</span></div>
<div class="line"><span class="keyword">auto</span> OptionalText(FString <span class="keyword">const</span>&amp; text) -&gt; <a class="code hl_typedef" href="df/df4/namespaceMcro_1_1Slate.html#a0a93c9ab0e9db18e32d30eab8bde6323">TAttributeBlock&lt;STextBlock&gt;</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> [&amp;](STextBlock::FArguments&amp; args) -&gt; <span class="keyword">auto</span>&amp;</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> args</div>
<div class="line">            . Visibility(<a class="code hl_function" href="df/df4/namespaceMcro_1_1Slate.html#a4fa0c2bf1d38dc606f82a421bb902d3e">IsVisible</a>(!text.IsEmpty()))</div>
<div class="line">            / Text(text);</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Accept attribute blocks as arguments</span></div>
<div class="line"><span class="keyword">auto</span> ExpandableText(</div>
<div class="line">    FText <span class="keyword">const</span>&amp; title,</div>
<div class="line">    FString <span class="keyword">const</span>&amp; text,</div>
<div class="line">    <a class="code hl_typedef" href="df/df4/namespaceMcro_1_1Slate.html#a0a93c9ab0e9db18e32d30eab8bde6323">TAttributeBlock&lt;STextBlock&gt;</a> <span class="keyword">const</span>&amp; textAttributes</div>
<div class="line">) -&gt; <a class="code hl_typedef" href="df/df4/namespaceMcro_1_1Slate.html#a0a93c9ab0e9db18e32d30eab8bde6323">TAttributeBlock&lt;SExpandableArea&gt;</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> [&amp;](SExpandableArea::FArguments&amp; args) -&gt; <span class="keyword">auto</span>&amp;</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> args</div>
<div class="line">            . Visibility(<a class="code hl_function" href="df/df4/namespaceMcro_1_1Slate.html#a4fa0c2bf1d38dc606f82a421bb902d3e">IsVisible</a>(!text.IsEmpty()))</div>
<div class="line">            . AreaTitle(title)</div>
<div class="line">            . InitiallyCollapsed(<span class="keyword">true</span>)</div>
<div class="line">            . BodyContent()</div>
<div class="line">            [</div>
<div class="line">                SNew(STextBlock) / textAttributes</div>
<div class="line">            ];</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceMcro_1_1Slate_html"><div class="ttname"><a href="df/df4/namespaceMcro_1_1Slate.html">Mcro::Slate</a></div><div class="ttdef"><b>Definition</b> <a href="d2/dc0/Slate_8h_source.html#l00018">Slate.h:19</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1Slate_html_a0a93c9ab0e9db18e32d30eab8bde6323"><div class="ttname"><a href="df/df4/namespaceMcro_1_1Slate.html#a0a93c9ab0e9db18e32d30eab8bde6323">Mcro::Slate::TAttributeBlock</a></div><div class="ttdeci">TUniqueFunction&lt; TArgumentsOf&lt; T &gt; &amp;(TArgumentsOf&lt; T &gt; &amp;)&gt; TAttributeBlock</div><div class="ttdef"><b>Definition</b> <a href="d2/dc0/Slate_8h_source.html#l00083">Slate.h:83</a></div></div>
<div class="ttc" id="anamespaceMcro_1_1Slate_html_a4fa0c2bf1d38dc606f82a421bb902d3e"><div class="ttname"><a href="df/df4/namespaceMcro_1_1Slate.html#a4fa0c2bf1d38dc606f82a421bb902d3e">Mcro::Slate::IsVisible</a></div><div class="ttdeci">MCRO_API EVisibility IsVisible(bool visible, EVisibility hiddenState=EVisibility::Collapsed)</div></div>
</div><!-- fragment --><p>Or add slots right in the Slate declarative syntax derived from an input array:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// This is just a convenience function so we don&#39;t repeat ourselves</span></div>
<div class="line"><span class="keyword">auto</span> Row() -&gt; SVerticalBox::FSlot::FSlotArguments</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> MoveTemp(SVerticalBox::Slot()</div>
<div class="line">        . HAlign(HAlign_Fill)</div>
<div class="line">        . AutoHeight()</div>
<div class="line">    );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Construct(FArguments <span class="keyword">const</span>&amp; inArgs)</div>
<div class="line">{</div>
<div class="line">    ChildSlot</div>
<div class="line">    [</div>
<div class="line">        SNew(SVerticalBox)</div>
<div class="line">        + Row()[ SNew(STextBlock) / Text(TEXT(<span class="stringliteral">&quot;Items:&quot;</span>)) ]</div>
<div class="line">        + <a class="code hl_struct" href="d0/daf/structMcro_1_1Slate_1_1TSlots.html">TSlots</a>(inArgs._Items.Get(), [&amp;](FString <span class="keyword">const</span>&amp; item)</div>
<div class="line">        {</div>
<div class="line">            return MoveTemp(</div>
<div class="line">                Row()[ SNew(STextBlock) / Text(item) ]</div>
<div class="line">            );</div>
<div class="line">        })</div>
<div class="line">        + Row()[ SNew(STextBlock) / Text(TEXT(<span class="stringliteral">&quot;Fin.&quot;</span>)) ]</div>
<div class="line">    ];</div>
<div class="line">}</div>
<div class="ttc" id="astructMcro_1_1Slate_1_1TSlots_html"><div class="ttname"><a href="d0/daf/structMcro_1_1Slate_1_1TSlots.html">Mcro::Slate::TSlots</a></div><div class="ttdef"><b>Definition</b> <a href="d2/dc0/Slate_8h_source.html#l00179">Slate.h:180</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
Text interop</h2>
<p>The <code><a class="el" href="d8/d6f/namespaceMcro_1_1Text.html">Mcro::Text</a></code> namespace provides some handy text templating and conversion utilities and interop between Unreal string and std::strings for third-party libraries.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;Mcro/Text&quot;</span>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="d8/d6f/namespaceMcro_1_1Text.html">Mcro::Text</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Accept many string types at once</span></div>
<div class="line"><span class="keyword">template</span> &lt;CStringOrViewOrName String&gt;</div>
<div class="line"><span class="keywordtype">bool</span> GetSomethingCommon(String&amp;&amp; input) { ... }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Work with std::string types</span></div>
<div class="line"><span class="keyword">template</span> &lt;CStdStringOrViewInvariant String&gt;</div>
<div class="line"><span class="keywordtype">size_t</span> GetLength(String&amp;&amp; input) { <span class="keywordflow">return</span> input.size(); }</div>
<div class="ttc" id="anamespaceMcro_1_1Text_html"><div class="ttname"><a href="d8/d6f/namespaceMcro_1_1Text.html">Mcro::Text</a></div><div class="ttdef"><b>Definition</b> <a href="d6/d35/Text_8h_source.html#l00019">Text.h:20</a></div></div>
</div><!-- fragment --><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// Type alias for choosing a std::string which is best matching the current TCHAR.</span></div>
<div class="line"><a class="code hl_typedef" href="d8/d6f/namespaceMcro_1_1Text.html#a2e8c067032afba88d5274e9060b7eb51">FStdString</a> foo(TEXT(<span class="stringliteral">&quot;bar&quot;</span>)); <span class="comment">// -&gt; std::wstring (on Windows at least)</span></div>
<div class="ttc" id="anamespaceMcro_1_1Text_html_a2e8c067032afba88d5274e9060b7eb51"><div class="ttname"><a href="d8/d6f/namespaceMcro_1_1Text.html#a2e8c067032afba88d5274e9060b7eb51">Mcro::Text::FStdString</a></div><div class="ttdeci">std::wstring FStdString</div><div class="ttdef"><b>Definition</b> <a href="d6/d35/Text_8h_source.html#l00030">Text.h:30</a></div></div>
</div><!-- fragment --><div class="fragment"><div class="line"> ++</div>
<div class="line">FString foo(TEXT(<span class="stringliteral">&quot;bar&quot;</span>));</div>
<div class="line">std::string fooNarrow = StdConvertUtf8(foo);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18"></a>
ISPC parallel tasks support</h2>
<p><code>McroISPC</code> module gives support for <code>task</code> and <code>launch</code> keywords of the ISPC language</p>
<div class="fragment"><div class="line">task <span class="keywordtype">void</span> MakeLookupUVLine(</div>
<div class="line">    uniform uint32 buffer[],</div>
<div class="line">    uniform uint32 width</div>
<div class="line">) {</div>
<div class="line">    uniform uint32 lineStart = taskIndex0 * width;</div>
<div class="line">    <span class="keywordflow">foreach</span> (i = 0 ... width)</div>
<div class="line">    {</div>
<div class="line">        varying uint32 address = lineStart + i;</div>
<div class="line">        buffer[address] = (i &lt;&lt; 16) | taskIndex0;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">export</span> <span class="keywordtype">void</span> MakeLookupUV(</div>
<div class="line">    uniform uint32 buffer[],</div>
<div class="line">    uniform uint32 width,</div>
<div class="line">    uniform uint32 height</div>
<div class="line">) {</div>
<div class="line">    launch [height] MakeLookupUVLine(buffer, width);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md19"></a>
Last but not least</h2>
<ul>
<li>Dynamic  Native (multicast) delegate interop</li>
<li>Event multiplexing to virtual function, native event, dynamic event</li>
<li>Object binding and promises for <code>AsyncTask</code></li>
<li>Bullet-proof third-party library include guards.</li>
<li>Rudimentary rendering utilities</li>
<li>In-place lambda initializers for both C++ objects and UObjects</li>
<li>RAII DLL loaders</li>
<li><code>IObservableModule</code></li>
<li>Universal API to get subsystems</li>
<li>Shared object utilities</li>
<li><code>FTimespan</code> literals</li>
<li>YAML utilities (via <a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a>)</li>
<li>Windows:<ul>
<li><code>IError</code> wrapper for <code>HRESULT</code> and <code>GetLastError</code> extracting human readable error messages from them.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md20"></a>
Legal</h1>
<p><a class="el" href="da/dfb/Attribution.html">Third-party components used by MCRO</a></p>
<p>When using MCRO in a plugin distributed via Fab, these components must be listed upon submission.</p>
<p>In addition the following tools and .NET libraries are used for build tooling:</p>
<ul>
<li><a href="https://nuke.build">NUKE</a></li>
<li><a href="https://github.com/scriban/scriban">Scriban</a></li>
<li><a href="https://github.com/Humanizr/Humanizer">Humanizer</a></li>
</ul>
<p>This library is distributed under the <b>Mozilla Public License Version 2.0</b> open-source software license. Each source code file where this license is applicable contains a comment about this.</p>
<p>Modifying those files or the entire library for commercial purposes is allowed but those modifications should also be published free and open-source under the same license. However files added by third-party for commercial purposes interfacing with the original files under MPL v2.0 are not affected by MPL v2.0 and therefore can have any form of copyright the third-party may choose.</p>
<p>Using this library in any product without modifications doesn't limit how that product may be licensed.</p>
<p><a href="https://mozilla.org/MPL/2.0/">Full text of the license</a></p>
<div align="center"></div><div align="center"><img src="proto-logo-1.webp" alt="" width="400" class="inline"/></div><div align="center"></div> </div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
